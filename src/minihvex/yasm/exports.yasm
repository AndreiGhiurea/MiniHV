%include "lib.yasm"

global ChangeStack

global LoadGDT

global LoadTR

global RestoreRegisters

align 0x10, db 0
[BITS 64]
; void __cdecl ChangeStack( IN PVOID InitialStackBase, IN PVOID NewStackBase )
ChangeStack:
    push    rdi
    push    rsi

    mov     r10,    rcx

    mov     rsi,    rcx     ; initial stack base
    mov     rdi,    rdx     ; new stack

    mov     rax,    rcx     ; rax <- initial stack base
    sub     rax,    rsp     ; rax <- current stack pointer
    mov     rcx,    rax     ; rcx <- how much of stack is used

    std                     ; we want to go backwards

    rep     movsb           ; we move the stack

    mov     rax,    r10
    sub     rax,    rsp

    sub     rdx,    rax

    mov     rsp,    rdx

    pop     rsi
    pop     rdi

    cld

    ret

align 0x10, db 0
[BITS 64]
; void __cdecl LoadTR( IN WORD GdtIndex )
LoadTR:
    ltr     cx
    ret

align 0x10, db 0
[BITS 64]
; void __cdecl LoadGDT( GDT* Gdt, IN WORD CodeSegmentSelector, IN WORD DataSegmentSelector )
LoadGDT:
    mov     r10,    rsp

    mov     rax,    rcx
    lgdt    [rax]

    xor     rax,    rax
    mov     ax,     dx

    push    rax
    call    $ + 5                   ; place return EIP onto the stack
    mov     eax,    10              ; instrux length to continue right after 'retf'
    add     [rsp],  eax
    retf

    mov     ax,     r8w
    mov     fs,     ax
    mov     gs,     ax

    mov     ss,     ax
    mov     rsp,    r10

    ret

align 0x10, db 0
[bits 64]
; void __cdecl* RestoreRegisters( PROCESSOR_STATE* ProcessorState )
RestoreRegisters:
    mov     rbx,    rcx

    AlignAddressUpper   rbx, XSAVE_AREA_REQUIRED_ALIGNMENT

    mov     edx,    0xFFFFFFFF
    mov     eax,    edx

    xrstor  QWORD   [rbx]

    mov     Rax,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rax]
    mov     Rdx,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdx]
    mov     Rbx,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbx]
    mov     Rbp,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rbp]
    mov     Rsi,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rsi]
    mov     Rdi,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rdi]

    mov     R8,     [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R8]
    mov     R9,     [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R9]
    mov     R10,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R10]
    mov     R11,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R11]
    mov     R12,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R12]
    mov     R13,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R13]
    mov     R14,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R14]
    mov     R15,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.R15]

    ; we leave rcx at the very end so we will still have a valid pointer
    mov     Rcx,    [rcx+COMPLETE_PROCESSOR_STATE.RegisterArea + REGISTER_AREA.Rcx]

    ret